! 
!                       __ _ 
!  _ |_  _ __ __  _  | |_ | \
! (_ | |(_|| || |(/_ | |  |_/
! 
! ---------------------------
! 
! This version of the channel flow aims at completely 
! separating the computation of the IBM coefficient from the 
! DNS engine. 
! 
! It also aims at being somewhat understandable, which means
! that it does not aim at having the most compact code possible
! at all costs. 
! 

! Some MPI variables
! -----------------------
INTEGER iprocx, nprocx=atoi(COMMANDLINE(1)), iprocy, nprocy=atoi(COMMANDLINE(2))
INTEGER iproc, nproc
BOOLEAN has_terminal

! Libraries to load
! -----------------------
USE complex
USE rbmat
!USE gnuplot
!USE rtchecks

! Librerie per la prima integrazione del codice tensegrity
INCLUDE modules/tensegrity_submodules/channel_inclusions.h


#define dns
USE modules/dns                          ! DNS input and definitions
USE modules/grid                         ! Staggered grid and difference coefficients
USE modules/imbc                         ! Immersed Boundary Coefficients (IMBC)
USE modules/parallel
!USE modules/poiseuille                   ! Flat still channel definitions
!USE modules/peristalsis                  ! Peristalsis input and definitions
USE modules/riblets                      ! Riblets input and definitions
USE modules/tensegrity                   ! Tensegrity fabric input and definition

! ==================================== 

! Defines
! ==================================== 

!#define cpg
!#define mpiverbose
#define chron
!#define randomDisturbance
#define WALLS
#define MOVINGWALLS
!#define EXTRA


! Initialisations
! ==================================== 
#ifdef chron
	USE wallclock
	REAL clock
#endif


! Inputs
! ==================================== 
REAL nu, headx, heady, UFR, VFR
INTEGER nx, ny, nz
REAL Lx, Ly, Lz
REAL cflmax, fouriermax, deltat, maxTime
INTEGER it_save, it_stat, it_max, it_cfl, it_check, it, non_ph
INTEGER it_runtimestats, it_start, it_end, iz_stats 
REAL time
BOOLEAN continue
		
! Read input file
DNS dns
STRING filename=WRITE("./input/dns.in")
readInputFile(dns,filename)

! Read parameters and grid from restart file
FILE savedfield=OPENRO("Field.fld")
IF savedfield#NULL THEN
STRING filename=WRITE("Field.fld")
readRestartFile(dns, filename)
END IF

nx=dns.size(0); ny=dns.size(1); nz=dns.size(2)
Lx=dns.leng(0); Ly=dns.leng(1); Lz=dns.leng(2)
nu=dns.nu
xd=dns.xd; yd=dns.yd; zd=dns.zd
headx=dns.headx; heady=dns.heady
UFR=dns.UFR; VFR=dns.VFR;
it=dns.it
cflmax=dns.cflmax; fouriermax=dns.fouriermax; deltat=dns.deltat; maxTime=dns.maxTime; time=dns.time
it_save=dns.it_save; it_stat=dns.it_stat; it_max=dns.it_max; it_cfl=dns.it_cfl; it_check=dns.it_check
it_runtimestats=dns.it_runtimestats; it_start=dns.it_start; it_end=dns.it_end; iz_stats=dns.iz_stats
continue=dns.continue
non_ph=dns.non_ph



! Definition of the geometry   !Uncomment the geometry you need
! ==================================== 
DYNAMIC POINTER geometry

  !Tensegrity fabric


  TENSEGRITY_INIT tensegrity_init
  STRING filename=WRITE("./input/tensegrity.in")
  readInputFile(tensegrity_init,filename)
  INTEGER n_t = CEILING(maxTime/deltat + 1)
  TENSEGRITY(tensegrity_init.nx, tensegrity_init.nz, tensegrity_init.n_C, tensegrity_init.n_B,
  			 tensegrity_init.n_T, tensegrity_init.n_G, tensegrity_init.n_N, tensegrity_init.n_N_dof,
  		 tensegrity_init.n_T_dof, tensegrity_init.n_q_tilde, tensegrity_init.n_P, tensegrity_init.n_int,
  			 tensegrity_init.n_tri_int, n_t) tensegrity
  initilizeTensegrity(tensegrity, tensegrity_init)
  geometry = tensegrity

  ! Output dati tensegrity fabric
  INCLUDE modules/tensegrity_submodules/output_utils.h
  ARRAY(10) OF INTEGER par_int_arr = (tensegrity.nx, tensegrity.nz, tensegrity.n_C, tensegrity.n_B, tensegrity.n_T, tensegrity.n_G, 
                                      tensegrity.n_N, tensegrity.n_N_dof, tensegrity.n_T_dof, tensegrity.n_q_tilde)
  ARRAY(2) OF REAL par_real_arr = (tensegrity.l_b, tensegrity.l_per)
  vec_to_csv_int(par_int_arr, "output/par_int_arr.csv")
  vec_to_csv_real(par_real_arr, "output/par_real_arr.csv")

  ! Modifica dimensioni dns.in in funzione della tensegrity fabric
  dns.leng(0) = tensegrity.nz*tensegrity.l_per
  dns.leng(1) = tensegrity.nx*tensegrity.l_per
  dns.leng(2) = 2 + tensegrity.h
  Lx = dns.leng(0)
  Ly = dns.leng(1) 
  Lz = dns.leng(2)

  mat_to_csv_int(tensegrity.B_con, "output/B_con.csv")
  mat_to_csv_int(tensegrity.T_con, "output/T_con.csv")
  mat_to_csv_int(tensegrity.P_mat(*,*,1), "output/P_mat.csv")
  mat_to_csv_int(tensegrity.P_mat(*,*,2), "output/P_mat_per.csv")
  mat_to_csv_int(tensegrity.ghost_nodes, "output/ghost_nodes.csv")
  vec_to_csv_real(tensegrity.X_0, "output/X_0.csv")

  mat_to_csv_real(tensegrity.q_tilde_arr, "output/q_tilde.csv")
  vec_to_csv_real(tensegrity.t_vec, "output/t.csv")


  !Poiseuille flow
  !POISEUILLE poiseuille
  !poiseuille.a=0
  !poiseuille.b=2  
  !geometry = poiseuille

  !Peristalsis
  !PERISTALSIS peristalsis
  !STRING filename=WRITE("./input/peristalsis.in")
  !readInputFile(peristalsis,filename)
  !peristalsis.time = time
  !DO zd(iz)=zd(iz) - ABS(peristalsis.a/(peristalsis.k*peristalsis.c)) FOR iz=0 TO 2*nz  !Remeber to changr Lz in dns.in
  !dns.zd=zd
  !geometry = peristalsis
  !deltat=peristalsis.Ndt*ABS(Lx/nx/peristalsis.c)
  !dns.deltat=deltat
  
  !Riblets
  !RIBLETS riblet
  !STRING filename=WRITE("./input/riblets.in")
  !readInputFile(riblet,filename)
  !geometry = riblet
  !DO zd(iz)=zd(iz) - ABS(0.5*riblet.h) FOR iz=0 TO 2*nz  !Remeber to change Lz in dns.in
  !Remeber to change Ly in dns.in to be a multiple of the spacing (otherwise the vimb coeffients are not right)


  
! Initialization
! ==================================== 
ARRAY(0..1) OF REAL cfl=0
INTEGER iN0
VARS = STRUCTURED ARRAY(p,u,v,w) OF REAL
INCLUDE parallelbcs.h
xx = ^xd(2*(*));   yy = ^yd(2*(*));   zz = ^zd(2*(*))
ARRAY[nxl(nx)-1..nxh(nx)+1,nyl(ny)-1..nyh(ny)+1,0..nz] OF VARS var = 0, old
STRUCTURED ARRAY(x,y) OF REAL flowrate = 0


USE parallelbcs
USE iofiles

! Define structures
! ------
#ifdef EXTRA
ARRAY[var.LO1..var.HI1,var.LO2..var.HI2] OF POINTER TO ARRAY(*,*) OF REAL uimbc,vimbc,wimbc,uimbc_rhs,vimbc_rhs
#ifdef WALLS
ARRAY[var.LO1..var.HI1,var.LO2..var.HI2] OF POINTER TO ARRAY(*,*) OF REAL Uuimbc,Uvimbc,Uwimbc,Uuimbc_rhs,Uvimbc_rhs
#endif
#else
ARRAY[var.LO1..var.HI1,var.LO2..var.HI2] OF POINTER TO ARRAY(*) OF REAL uimbc=0,vimbc=0,wimbc=0
#ifdef WALLS
ARRAY[var.LO1..var.HI1,var.LO2..var.HI2] OF POINTER TO ARRAY(*) OF REAL Uuimbc=0,Uvimbc=0,Uwimbc=0
#endif
#endif


USE timestep

! Initialise MPI
mpiInit(dns)

! Compute IMB coefficient
! ==================================== 
GRID uGrid, vGrid, wGrid, pGrid
initialiseGrid(uGrid, dns, [1,0,0])
initialiseGrid(vGrid, dns, [0,1,0])
initialiseGrid(wGrid, dns, [0,0,1])
initialiseGrid(pGrid, dns, [0,0,0])


#ifdef WALLS
! Allocate IBM coefficients upper wall
Uallocate(Uuimbc, dns, uGrid, geometry)
Uallocate(Uvimbc, dns, vGrid, geometry)
Uallocate(Uwimbc, dns, wGrid, geometry)
! Populate IBM coefficients upper wall
UpopulateCoeff(Uuimbc, dns, uGrid, pGrid, geometry)
UpopulateCoeff(Uvimbc, dns, vGrid, pGrid, geometry)
UpopulateCoeff(Uwimbc, dns, wGrid, pGrid, geometry)
#endif

! Allocate IBM coefficients lower wall
allocate(uimbc, dns, uGrid, geometry)
allocate(vimbc, dns, vGrid, geometry)
allocate(wimbc, dns, wGrid, geometry)
! Populate IBM coefficients lower wall
populateCoeff(uimbc, dns, uGrid, pGrid, geometry)
populateCoeff(vimbc, dns, vGrid, pGrid, geometry)
populateCoeff(wimbc, dns, wGrid, pGrid, geometry)


! Defining other IBM coefficients when needed
#ifdef WALLS
#ifdef EXTRA
DO 
   	Uuimbc(ix,iy) = NEW ARRAY((nz-uimbc(ix,iy,*,0).HI)..(nz-uimbc(ix,iy,*,0).LO),0..4) OF REAL
     	DO Uuimbc(ix,iy,nz-iz,0) = uimbc(ix,iy,iz,0) FOR iz=uimbc(ix,iy,*,0).LO TO uimbc(ix,iy,*,0).HI
     	DO Uuimbc(ix,iy,nz-iz,1) = 0 FOR iz=uimbc(ix,iy,*,1).LO TO uimbc(ix,iy,*,1).HI
     	DO Uuimbc(ix,iy,nz-iz,2) = 0 FOR iz=uimbc(ix,iy,*,2).LO TO uimbc(ix,iy,*,2).HI
     	DO Uuimbc(ix,iy,nz-iz,3) = 0 FOR iz=uimbc(ix,iy,*,3).LO TO uimbc(ix,iy,*,3).HI
     	DO Uuimbc(ix,iy,nz-iz,4) = 0 FOR iz=uimbc(ix,iy,*,4).LO TO uimbc(ix,iy,*,4).HI
     
     	Uvimbc(ix,iy) = NEW ARRAY((nz-vimbc(ix,iy,*,0).HI)..(nz-vimbc(ix,iy,*,0).LO),0..4) OF REAL
	DO Uvimbc(ix,iy,nz-iz,0) = vimbc(ix,iy,iz,0) FOR iz=vimbc(ix,iy,*,0).LO TO vimbc(ix,iy,*,0).HI
	DO Uvimbc(ix,iy,nz-iz,1) = 0 FOR iz=vimbc(ix,iy,*,1).LO TO vimbc(ix,iy,*,1).HI
	DO Uvimbc(ix,iy,nz-iz,2) = 0 FOR iz=vimbc(ix,iy,*,2).LO TO vimbc(ix,iy,*,2).HI
	DO Uvimbc(ix,iy,nz-iz,3) = 0 FOR iz=vimbc(ix,iy,*,3).LO TO vimbc(ix,iy,*,3).HI
	DO Uvimbc(ix,iy,nz-iz,4) = 0 FOR iz=vimbc(ix,iy,*,4).LO TO vimbc(ix,iy,*,4).HI
     
     	Uwimbc(ix,iy) = NEW ARRAY((nz-1-wimbc(ix,iy,*,0).HI)..(nz-1-wimbc(ix,iy,*,0).LO),0..4) OF REAL
     	DO Uwimbc(ix,iy,nz-1-iz,0) = wimbc(ix,iy,iz,0) FOR iz=wimbc(ix,iy,*,0).LO TO wimbc(ix,iy,*,0).HI
     	DO Uwimbc(ix,iy,nz-1-iz,1) = 0 FOR iz=wimbc(ix,iy,*,1).LO TO wimbc(ix,iy,*,1).HI
     	DO Uwimbc(ix,iy,nz-1-iz,2) = 0 FOR iz=wimbc(ix,iy,*,2).LO TO wimbc(ix,iy,*,2).HI
     	DO Uwimbc(ix,iy,nz-1-iz,3) = 0 FOR iz=wimbc(ix,iy,*,3).LO TO wimbc(ix,iy,*,3).HI
     	DO Uwimbc(ix,iy,nz-1-iz,4) = 0 FOR iz=wimbc(ix,iy,*,4).LO TO wimbc(ix,iy,*,4).HI
     		
     	Uuimbc_rhs(ix,iy) = NEW ARRAY((nz-uimbc_rhs(ix,iy,*,0).HI)..(nz-uimbc_rhs(ix,iy,*,0).LO),0..4) OF REAL
     	DO Uuimbc_rhs(ix,iy,nz-iz,0) = uimbc_rhs(ix,iy,iz,0) FOR iz=uimbc_rhs(ix,iy,*,0).LO TO uimbc_rhs(ix,iy,*,0).HI
     	DO Uuimbc_rhs(ix,iy,nz-iz,1) = uimbc_rhs(ix,iy,iz,1) FOR iz=uimbc_rhs(ix,iy,*,1).LO TO uimbc_rhs(ix,iy,*,1).HI
     	DO Uuimbc_rhs(ix,iy,nz-iz,2) = uimbc_rhs(ix,iy,iz,2) FOR iz=uimbc_rhs(ix,iy,*,2).LO TO uimbc_rhs(ix,iy,*,2).HI
     	DO Uuimbc_rhs(ix,iy,nz-iz,3) = uimbc_rhs(ix,iy,iz,3) FOR iz=uimbc_rhs(ix,iy,*,3).LO TO uimbc_rhs(ix,iy,*,3).HI
     	DO Uuimbc_rhs(ix,iy,nz-iz,4) = uimbc_rhs(ix,iy,iz,4) FOR iz=uimbc_rhs(ix,iy,*,4).LO TO uimbc_rhs(ix,iy,*,4).HI
     
     	Uvimbc_rhs(ix,iy) = NEW ARRAY((nz-vimbc_rhs(ix,iy,*,0).HI)..(nz-vimbc_rhs(ix,iy,*,0).LO),0..4) OF REAL
     	DO Uvimbc_rhs(ix,iy,nz-iz,0) = vimbc_rhs(ix,iy,iz,0) FOR iz=vimbc_rhs(ix,iy,*,0).LO TO vimbc_rhs(ix,iy,*,0).HI
     	DO Uvimbc_rhs(ix,iy,nz-iz,1) = vimbc_rhs(ix,iy,iz,1) FOR iz=vimbc_rhs(ix,iy,*,1).LO TO vimbc_rhs(ix,iy,*,1).HI
     	DO Uvimbc_rhs(ix,iy,nz-iz,2) = vimbc_rhs(ix,iy,iz,2) FOR iz=vimbc_rhs(ix,iy,*,2).LO TO vimbc_rhs(ix,iy,*,2).HI
     	DO Uvimbc_rhs(ix,iy,nz-iz,3) = vimbc_rhs(ix,iy,iz,3) FOR iz=vimbc_rhs(ix,iy,*,3).LO TO vimbc_rhs(ix,iy,*,3).HI
     	DO Uvimbc_rhs(ix,iy,nz-iz,4) = vimbc_rhs(ix,iy,iz,4) FOR iz=vimbc_rhs(ix,iy,*,4).LO TO vimbc_rhs(ix,iy,*,4).HI

FOR ALL ix,iy
#endif
#endif






IF NOT continue THEN 
! Imposing zero velocity in the geometry or the prescribed velocity
! -------------------------
	LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
#ifdef EXTRA
		DO var(ix,iy,iz).u = 0 FOR iz=0 TO uimbc(ix,iy,*,0).LO-1
   		DO var(ix,iy,iz).v = 0 FOR iz=0 TO vimbc(ix,iy,*,0).LO-1
   		DO var(ix,iy,iz).w = 0 FOR iz=0 TO wimbc(ix,iy,*,0).LO-1
#else
		DO var(ix,iy,iz).u = 0 FOR iz=0 TO uimbc(ix,iy).LO-1
   		DO var(ix,iy,iz).v = 0 FOR iz=0 TO vimbc(ix,iy).LO-1
   		DO var(ix,iy,iz).w = 0 FOR iz=0 TO wimbc(ix,iy).LO-1
#ifdef MOVINGWALLS
               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy)) FOR iz=0 TO wimbc(ix,iy).LO-1 
#endif	
#endif
#ifdef WALLS
#ifdef EXTRA
   		DO var(ix,iy,iz).u = 0 FOR iz=Uuimbc(ix,iy,*,0).HI+1 TO nz
   		DO var(ix,iy,iz).v = 0 FOR iz=Uvimbc(ix,iy,*,0).HI+1 TO nz
   		DO var(ix,iy,iz).w = 0 FOR iz=Uwimbc(ix,iy,*,0).HI+1 TO nz-1  		
#else
   		DO var(ix,iy,iz).u = 0 FOR iz=Uuimbc(ix,iy).HI+1 TO nz
   		DO var(ix,iy,iz).v = 0 FOR iz=Uvimbc(ix,iy).HI+1 TO nz
   		DO var(ix,iy,iz).w = 0 FOR iz=Uwimbc(ix,iy).HI+1 TO nz-1
#ifdef MOVINGWALLS
               DO var(ix,iy,iz).w=Uwbc(geometry,xd(ix),yd(iy)) FOR iz=Uwimbc(ix,iy).HI+1 TO nz-1 
#endif	
#endif
#endif
	REPEAT

! Check that the initial condition fulfills the boundary conditions
! -------------------------
#ifdef WALLS
	var(var.LO1..var.HI1,var.LO2..var.HI2,0)=0
	var(var.LO1..var.HI1,var.LO2..var.HI2,nz).u=0
	var(var.LO1..var.HI1,var.LO2..var.HI2,nz).v=0
	var(var.LO1..var.HI1,var.LO2..var.HI2,nz-1).w=0
	var(var.LO1..var.HI1,var.LO2..var.HI2,nz).p=0
#ifdef MOVINGWALLS
	  LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	  var(ix,iy,0).w=wbc(geometry,xd(ix),yd(iy))  
	  var(ix,iy,nz-1).w=Uwbc(geometry,xd(ix),yd(iy))   
	  REPEAT
#endif	
#else
	var(var.LO1..var.HI1,var.LO2..var.HI2,nz-1).w=0
  	var(var.LO1..var.HI1,var.LO2..var.HI2,nz-1).p=0
  	var(var.LO1..var.HI1,var.LO2..var.HI2,0)=0
#ifdef MOVINGWALLS
	  LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1 
	  var(ix,iy,0).w=wbc(geometry,xd(ix),yd(iy))   
	  REPEAT
#endif
#endif

END IF

! Prova






! Timeloop
! -------------------------
INTEGER it_max_new
REAL cflmax_it
SUBROUTINE time_loop()
	LOOP timeloop WHILE it<it_max OR time<maxTime
  	! Every it_cfl iterations, check the CFL and impose the new timestep
	! ------

#ifdef MOVINGWALLS

! Update time if needed
tensegrity.time=time
geometry=tensegrity



!Recompute coefficients
! Imbc

#ifdef WALLS
! Allocate IBM coefficients upper wall
Uallocate(Uuimbc, dns, uGrid, geometry)
Uallocate(Uvimbc, dns, vGrid, geometry)
Uallocate(Uwimbc, dns, wGrid, geometry)
! Populate IBM coefficients upper wall
UpopulateCoeff(Uuimbc, dns, uGrid, pGrid, geometry)
UpopulateCoeff(Uvimbc, dns, vGrid, pGrid, geometry)
UpopulateCoeff(Uwimbc, dns, wGrid, pGrid, geometry)
#endif
! Allocate IBM coefficients lower wall
allocate(uimbc, dns, uGrid, geometry)
allocate(vimbc, dns, vGrid, geometry)
allocate(wimbc, dns, wGrid, geometry)
! Populate IBM coefficients lower wall
populateCoeff(uimbc, dns, uGrid, pGrid, geometry)
populateCoeff(vimbc, dns, vGrid, pGrid, geometry)
populateCoeff(wimbc, dns, wGrid, pGrid, geometry)
#endif

		! Riga commentata per mantenere costante il deltat
		!{IF it#0 AND it MOD it_cfl = 0 THEN
			get_cfl()
			IF it < 1000 THEN cflmax_it = 0.1; ELSE IF it < 5000 THEN cflmax_it = 0.5; ELSE cflmax_it = cflmax;	END IF 
			IF non_ph=0 THEN cflmax_it = cflmax
			WRITE BY NAME cflmax_it
			WRITE BY NAME cfl(0)
			IF cflmax_it>0 THEN deltat=cflmax_it/cfl(0) END IF
			IF (cfl(1)*deltat)>fouriermax THEN deltat=fouriermax/cfl(1) END IF
		END IF!}
#ifdef chron
  	  		IF has_terminal THEN clock=wallclock()
#endif
	! Run the RK3 integration and check the BCs
	! ------



!Boundary conditions	
#ifdef WALLS
		IF non_ph=0 THEN 
			DO var(ix,iy,FLOOR(0.5*(nz+1))).u=1.0 FOR ALL ix,iy; DO var(ix,iy,FLOOR(0.5*(nz-1))).u=1.0 FOR ALL ix,iy; 
			DO var(ix,iy,FLOOR(0.5*(nz+1))).v=1.0 FOR ALL ix,iy; DO var(ix,iy,FLOOR(0.5*(nz-1))).v=1.0 FOR ALL ix,iy 
		END IF
#ifdef MOVINGWALLS      		
	        LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy)) FOR iz=0 TO wimbc(ix,iy).LO-1 
	               DO var(ix,iy,iz).w=Uwbc(geometry,xd(ix),yd(iy)) FOR iz=Uwimbc(ix,iy).HI+1 TO nz-1
	        REPEAT
#endif
#else
                DO var(ix,iy,nz,0..2)=var(ix,iy,nz-1,0..2); var(ix,iy,nz).w=-var(ix,iy,nz-2).w FOR ALL ix,iy
                IF non_ph=0 THEN DO var(ix,iy,nz).u=1.0 FOR ALL ix,iy; DO var(ix,iy,nz).v=1.0 FOR ALL ix,iy; END IF
#ifdef MOVINGWALLS
	        LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy))  FOR iz=0 TO wimbc(ix,iy).LO-1   
	        REPEAT		
#endif
#endif



!Timestep
		timestep(rai1)
!Boundary conditions	
#ifdef WALLS
		IF non_ph=0 THEN 
			DO var(ix,iy,FLOOR(0.5*(nz+1))).u=1.0 FOR ALL ix,iy; DO var(ix,iy,FLOOR(0.5*(nz-1))).u=1.0 FOR ALL ix,iy; 
			DO var(ix,iy,FLOOR(0.5*(nz+1))).v=1.0 FOR ALL ix,iy; DO var(ix,iy,FLOOR(0.5*(nz-1))).v=1.0 FOR ALL ix,iy 
		END IF
#ifdef MOVINGWALLS
	        LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy)) FOR iz=0 TO wimbc(ix,iy).LO-1 
	               DO var(ix,iy,iz).w=Uwbc(geometry,xd(ix),yd(iy)) FOR iz=Uwimbc(ix,iy).HI+1 TO nz-1
	        REPEAT
#endif
#else
                DO var(ix,iy,nz,0..2)=var(ix,iy,nz-1,0..2); var(ix,iy,nz).w=-var(ix,iy,nz-2).w FOR ALL ix,iy
!                IF non_ph=0 THEN DO var(ix,iy,nz).u=1.0 FOR ALL ix,iy; DO var(ix,iy,nz).v=1.0 FOR ALL ix,iy; END IF
#ifdef MOVINGWALLS
	        LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy))  FOR iz=0 TO wimbc(ix,iy).LO-1   
	        REPEAT
#endif		
#endif
!Timestep
 		timestep(rai2)
!Boundary conditions	
#ifdef WALLS
		IF non_ph=0 THEN 
			DO var(ix,iy,FLOOR(0.5*(nz+1))).u=1.0 FOR ALL ix,iy; DO var(ix,iy,FLOOR(0.5*(nz-1))).u=1.0 FOR ALL ix,iy; 
			DO var(ix,iy,FLOOR(0.5*(nz+1))).v=1.0 FOR ALL ix,iy; DO var(ix,iy,FLOOR(0.5*(nz-1))).v=1.0 FOR ALL ix,iy 
		END IF
#ifdef MOVINGWALLS
	        LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy)) FOR iz=0 TO wimbc(ix,iy).LO-1 
	               DO var(ix,iy,iz).w=Uwbc(geometry,xd(ix),yd(iy)) FOR iz=Uwimbc(ix,iy).HI+1 TO nz-1
	        REPEAT
#endif
#else
                DO var(ix,iy,nz,0..2)=var(ix,iy,nz-1,0..2); var(ix,iy,nz).w=-var(ix,iy,nz-2).w FOR ALL ix,iy
                IF non_ph=0 THEN DO var(ix,iy,nz).u=1.0 FOR ALL ix,iy; DO var(ix,iy,nz).v=1.0 FOR ALL ix,iy; END IF
#ifdef MOVINGWALLS
	        LOOP FOR ix=var.LO1+1 TO var.HI1-1 AND iy=var.LO2+1 TO var.HI2-1
	               DO var(ix,iy,iz).w=wbc(geometry,xd(ix),yd(iy))  FOR iz=0 TO wimbc(ix,iy).LO-1   
	        REPEAT
#endif		
#endif
!Timestep
	 	timestep(rai3) 	
	  	INC it
		#ifdef randomDisturbance
	  		IF it<500 THEN DO var(ix,iy,iz).u=~+deltat*100*0.2*(RAND()-0.5) FOR ix=LO+1 TO HI-1 AND iy=LO+1 TO HI-1 AND iz=LO+1 TO HI-1
		#endif
		
	! Write the files
	! ------
	  	output
	  	outputRuntime
	  	IF it MOD it_save = 0 THEN savefield("Field"it DIV it_save".fld")
#ifdef chron
	  		IF has_terminal THEN WRITE "elapsed time per timestep: "wallclock()-clock" s"
#endif
  	  	time=~+deltat
  	  	

	! Check the on the run input files to see if the user changed it_save, it_max or it_check
	! It's been checked every it_check times
	! ------
	  	IF it MOD it_check = 0 THEN 
			FILE rereadfile=OPENRO('reread')
			IF rereadfile#NULL THEN 
			    readInput()
			    CLOSE rereadfile
			    remove('reread')
			END IF
	  	END IF

	
	! Timestep Tensegrity
	timestep_tensegrity(geometry, time-deltat, deltat) 
	X_comp_upd(tensegrity)
	X_dot_comp_upd(tensegrity)


	REPEAT timeloop
END time_loop
time_loop()

! Dump the field in the original file. This is done even if it_save and it do not match
! ------
savefield("Field.fld")
save_statsX()

CLOSE runtimedata
CLOSE runtimestats


