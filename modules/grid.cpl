USE dns

GRID = STRUCTURE[ STRUCTURED ARRAY(x,y,z) OF POINTER TO ARRAY(*) OF REAL xd; 
                  STRUCTURED ARRAY(x,y,z) OF POINTER TO ARRAY(*) OF REAL x;
                  STRUCTURED ARRAY(x,y,z) OF INTEGER di;
                  STRUCTURED ARRAY(x,y,z) OF POINTER TO ARRAY(*,*) OF REAL delta, d2
                ]
   
SUBROUTINE initialiseGrid(GRID this^; DNS dns; ARRAY(*) OF INTEGER di) FOLLOWS
                                   
MODULE staggeredGrid
 
	SUBROUTINE initialiseGrid(GRID this^; DNS dns; ARRAY(*) OF INTEGER di)
                ! This subroutine at the moment initialises a grid for a 
                ! the case of a channel flow with two periodic direction and 
                ! an inhomogeneous grid in the nonperiodic direction. The routine
                ! could and (in future) should be made generic by using sub-subroutine
                ! that initialise the grid per each direction by taking as input
                ! the info if a direction is periodic.
                !
                ! The array structures are prepared for the extension to generic grids 
                ! 
		this.di = di((*)+di.LO)
		this.xd(0) = dns.xd(*)
		this.xd(1) = dns.yd(*)
		this.xd(2) = dns.zd(*)
		LOOP FOR iC = 0 TO 2
			this.x(iC) = ^this.xd(iC,2*(*)+this.di(iC))
			this.delta(iC) = NEW ARRAY(this.x(iC).LO+1..this.x(iC).HI-1,-1..1) OF REAL
			this.d2(iC) = NEW ARRAY(this.x(iC).LO+1..this.x(iC).HI-1,-1..1) OF REAL 
			DO 				
				this.delta(iC,i,-1) = this.x(iC,i)-this.x(iC,i-1)

				this.delta(iC,i, 0) = 0
				this.delta(iC,i, 1) = this.x(iC,i+1)-this.x(iC,i)
				this.d2(iC,i,-1) = 1/this.delta(iC,i,-1)/[this.xd(iC,2*i+this.di(iC)+1)-this.xd(iC,2*i+this.di(iC)-1)]
				this.d2(iC,i, 0) = 0
				this.d2(iC,i, 1) = 1/this.delta(iC,i, 1)/[this.xd(iC,2*i+this.di(iC)+1)-this.xd(iC,2*i+this.di(iC)-1)]
			FOR i = this.delta(iC).LO TO this.delta(iC).HI                       
		REPEAT
	END initialiseGrid 

END staggeredGrid
